(()=>{var e={924:e=>{e.exports=Object.freeze(new function(){this.TASKER_PATH="Tasker",this.MAX_WALLPAPERS=1e3,this.PREVIOUS_FILEPATH=this.TASKER_PATH+"/wallpaper/previous.json",this.IMAGE_PATH=this.TASKER_PATH+"/wallpaper/images",this.REDDIT_CLIENT_BASE_URL="https://reddit.premii.com/#",this.REDDIT_WALLPAPER_SOURCE_URL="https://reddit.com/r/art.json",this.MIN_WIDTH=1080,this.MIN_HEIGHT=1920})}},t={};function a(r){var i=t[r];if(void 0!==i)return i.exports;var l=t[r]={exports:{}};return e[r](l,l.exports,a),l.exports}(()=>{"use strict";const e=this;var t=a(924);const r=({url:e})=>RegExp(".(jpg|png|jpeg)$","i").test(e),i=(a,r=t.PREVIOUS_FILEPATH)=>(0,e.writeFile)(r,JSON.stringify(a)),l=(t,a)=>(0,e.performTask)("WallpaperNotification",10,t,a),s=(a=t.IMAGE_PATH)=>{const r=(0,e.listFiles)(a);return r?r.split("\n").reduce(((e,t)=>{const a=t.match(/(\w+)\.\w{3,4}$/);return a?(e.push({id:a[1],filePath:t}),e):e}),[]):[]},o=(a,r=t.IMAGE_PATH,n=t.PREVIOUS_FILEPATH)=>{console.log("Start offline");const d=s(r),h=a.filter((e=>Boolean(e)));if(!d.length||!a.length)return(0,e.flash)("Could not set offline wallpaper with no cached images"),a;const c=h.pop(),p=d.find((({id:e})=>e===c.id));return p||o(h),(0,e.setWallpaper)(p.filePath),l(c.title,`${t.REDDIT_CLIENT_BASE_URL}${c.permalink}`),(0,e.setGlobal)("WallpaperPostUrl",`${t.REDDIT_CLIENT_BASE_URL}${c.permalink}`),c.displayedLast=Date.now(),h.unshift(c),h.length=a.length,i(h,n),h},n=o,d=({width:e,height:a})=>e>=t.MIN_WIDTH&&a>=t.MIN_HEIGHT,h=async(t,a)=>{if((0,e.shell)("curl --help",!1,10))((t,a)=>{const r=`cd /storage/emulated/0 && curl -L -f -o "${a}" "${t}" && echo done`;if(!(0,e.shell)(r,!1,45))throw new Error(`Curl wallpaper download errored with commmand: ${r}`)})(t,a);else{if(!(0,e.shell)("base64 --help",!1,10))throw new Error("Neither curl or base64 commands precent in shell, no methods available to download image");await(async(t,a)=>{const r=await(0,e.fetch)(t),i=await r.blob(),l=await(e=>new Promise(((t,a)=>{const r=new FileReader;r.onloadend=()=>t(r.result),r.readAsDataURL(e)})))(i),s=`echo '${l.match(/^data:image\/[a-z]+;base64,(?<base>.+)$/).groups.base}' | base64 -d > /storage/emulated/0/${a} && echo done`;if(!(0,e.shell)(s,!1,45))throw new Error(`shell command failed Tasker JS does not include error, ${s}`)})(t,a)}},c=async(a=[],s,o=t.IMAGE_PATH,n=t.PREVIOUS_FILEPATH,p=null)=>{const[E,w]=await(async a=>{const i=await(0,e.fetch)(`${t.REDDIT_WALLPAPER_SOURCE_URL}?limit=100${a?`&after=${a}`:""}`),l=await i.json(),s=l.data.children.map((e=>(({id:e,title:t,permalink:a,url:r,preview:i})=>({id:e,title:t,permalink:a,url:r,width:i&&i.images&&i.images.length&&i.images[0].source&&i.images[0].source.width?i.images[0].source.width:0,height:i&&i.images&&i.images.length&&i.images[0].source&&i.images[0].source.height?i.images[0].source.height:0}))(e.data)));return[l.data.after,s.filter(r).filter(d)]})(s),f=w.find((e=>!a.find((t=>t&&t.id===e.id))));if(!f){if(!E)throw new Error("Can not paginate without a after parameter");if(Boolean(p)&&p>=Date.now())throw new Error("Could not find new wallpaper within timeout");return c(a,E,o,n)}const[u]=f.url.match(/\.\w{3,4}($|\?)/),g=`${o}/${f.id}${u}`;await h(f.url,g),(0,e.setWallpaper)(g),l(f.title,`${t.REDDIT_CLIENT_BASE_URL}${f.permalink}`),(0,e.setGlobal)("WallpaperPostUrl",`${t.REDDIT_CLIENT_BASE_URL}${f.permalink}`),f.displayedLast=Date.now(),a.unshift(f);const m=(0,e.global)("%WallpaperMemLength");return m||(0,e.setGlobal)("%WallpaperMemLength",t.MAX_WALLPAPERS),a.length=m||t.MAX_WALLPAPERS,i(a,n),a},p=async(e=[],a,r=t.IMAGE_PATH,i=t.PREVIOUS_FILEPATH,l=3e4)=>{console.log("Start online");const s=Date.now()+l;return await c(e,a,r,i,s)};(async()=>{try{l("Updating wallpaper...");const a=((a=t.PREVIOUS_FILEPATH)=>{try{return JSON.parse((0,e.readFile)(a)).sort(((e,t)=>e&&t?t.displayedLast-e.displayedLast:0)).filter(((e,t,a)=>!e||t===a.filter((e=>Boolean(e))).findIndex((t=>e.id===t.id))))}catch(t){"ENOENT"!==t.code&&console.error(t),(0,e.writeFile)(a,"[]")}return[]})(),[r,i]=(0,e.global)("%WIFII").match(/>>> (.+) <<</);(t=>{s().filter((({id:e})=>!t.find((t=>t&&t.id===e)))).forEach((({filePath:t})=>(0,e.deleteFile)(t)))})(await(!(0,e.global)("sdk")&&process.argv.includes("--online")?p:!(0,e.global)("sdk")&&process.argv.includes("--offline")?n:"CONNECTION"===i?p:n)(a))}catch(t){console.error(t),(0,e.flash)(t.toString())}(0,e.exit)()})()})()})();